package display;

import java.awt.Canvas;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.image.BufferStrategy;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPopupMenu;
import javax.swing.plaf.FontUIResource;

public class ViewFrameImpl extends javax.swing.JFrame implements ViewFrame {

    private final HashMap<String, ConsoleItem> points = new HashMap<>();
    private final ArrayList<Point> stars = new ArrayList<>();
    private final ViewLoop viewLoop;
    private String info = "";
    private boolean showGrid = true;
    private boolean showStars = true;

    public ViewFrameImpl() {
        initComponents();
        setTitle("Space View Frame");
        gui.setSize(ViewManager.getXSize(), ViewManager.getYSize());
        pack();
        setVisible(true);

        viewLoop = new ViewLoop(gui);
        Thread gameThread = new Thread(viewLoop);
        gameThread.setPriority(Thread.MIN_PRIORITY);
        gameThread.start(); // start processing.

        javax.swing.UIManager.put("OptionPane.messageFont", new FontUIResource(new Font("Monospaced", Font.BOLD, 12)));
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        gui = new java.awt.Canvas();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setResizable(false);

        gui.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                guiMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(gui, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(gui, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    @Override
    public void toggleGrid() {
        showGrid = !showGrid;
    }

    @Override
    public void toggleStars() {
        showStars = !showStars;
    }
    private void guiMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_guiMouseClicked
        if (evt.getButton() == MouseEvent.BUTTON1) {
            ConsoleItem s = findClosest(evt.getPoint());
            JOptionPane.showMessageDialog(this, s.getInfoText(), "ID: " + s.getId(), JOptionPane.INFORMATION_MESSAGE);

        } else if (evt.getButton() == MouseEvent.BUTTON3) {
            JPopupMenu pop = new JPopupMenu();

            JMenuItem menuItem = new JMenuItem("Toggle Grid");
            menuItem.addActionListener(new ActionListener() {

                @Override
                public void actionPerformed(ActionEvent e) {
                    ViewManager.getInstance().toggleGrid();
                }
            });
            pop.add(menuItem);

            menuItem = new JMenuItem("Toggle Stars");
            menuItem.addActionListener(new ActionListener() {

                @Override
                public void actionPerformed(ActionEvent e) {
                    ViewManager.getInstance().toggleStars();
                }
            });
            pop.add(menuItem);
            pop.show(evt.getComponent(), evt.getX(), evt.getY());
        }
    }//GEN-LAST:event_guiMouseClicked

    @Override
    public int getXSize() {
        return ViewManager.getXSize();
    }

    @Override
    public int getYSize() {
        return ViewManager.getYSize();
    }

    @Override
    public int getZSize() {
        return ViewManager.getZSize();
    }

    @Override
    public void updateInfo(String s) {
        info = s;
    }

    @Override
    public boolean isStopped() {
        return !viewLoop.isRunning();
    }

    @Override
    public void stop() {
        viewLoop.stopRunning();
        setVisible(false);
    }

    @Override
    public void updateItem(ConsoleItem ci) {
        synchronized (points) {
            points.put(ci.getId(), ci);
        }
    }

    private ConsoleItem findClosest(Point p) {
        double distance = Integer.MAX_VALUE;
        ConsoleItem closest = null;

        synchronized (points) {
            for (ConsoleItem ci : points.values()) {
                double d = p.distance(ci.getLocation().getX(), ci.getLocation().getY());
                if (d < distance) {
                    distance = d;
                    closest = ci;
                }
            }
        }
        return closest;
    }

    @Override
    public int numItems() {
        return points.size();
    }

    @Override
    public void clearAllItems() {
        synchronized (points) {
            points.clear();
        }
    }

    @Override
    public void removeItem(String id) {
        synchronized (points) {
            points.remove(id);
        }
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private java.awt.Canvas gui;
    // End of variables declaration//GEN-END:variables

    private class ViewLoop implements Runnable {

        private static final int FRAME_DELAY = 20; // 20ms. implies 50fps (1000/20) = 50
        private boolean isRunning;
        private boolean paused;
        private final Canvas gui;
        private long cycleTime;

        public ViewLoop(Canvas canvas) {
            gui = canvas;
            isRunning = true;
        }

        public void stopRunning() {
            isRunning = false;
        }

        public boolean isPaused() {
            return paused;
        }

        public void setPaused(boolean value) {
            paused = value;
        }

        public boolean isRunning() {
            return isRunning;
        }

        @Override
        public void run() {
            System.out.println("View Frame Running...");
            cycleTime = System.currentTimeMillis();
            gui.createBufferStrategy(2);
            BufferStrategy strategy = gui.getBufferStrategy();

            // View Loop
            while (isRunning) {
                //System.out.println(points.keySet());
                updateGUI(strategy);
                synchFramerate();
            }

            try {
                Thread.sleep(500);
            } catch (InterruptedException ex) {
                Logger.getLogger(ViewFrameImpl.class.getName()).log(Level.SEVERE, null, ex);
            }
            System.out.println("View Frame Shutdown...");
        }

        private void updateGUI(BufferStrategy strategy) {

            Graphics g = strategy.getDrawGraphics();
            g.setColor(Color.black);
            g.fillRect(0, 0, gui.getWidth(), gui.getHeight());

            ArrayList<ConsoleItem> allItems;
            synchronized (points) {
                allItems = new ArrayList<>(points.values());
            }

            for (ConsoleItem ci : allItems) {
                if (ci.isDestroyed()) {
                    synchronized (points) {
                        points.remove(ci.getId());
                    }
                    continue;
                }
                g.setColor((ci.isDamaged() ? ci.getColor().darker().darker() : ci.getColor()));
                g.fillPolygon(ci.getPolygon(getZSize()));
            }

            drawLegend(g);
            drawCoords(g);
            if (showGrid) {
                drawGrid(g);
            }

            drawSummary(g);

            if (showStars) {
                drawStars(g);
            }

            g.dispose();
            strategy.show();
        }

        private void drawStars(Graphics g) {

            int avgSize = (gui.getWidth() + gui.getHeight()) / 10;
            if (stars.isEmpty()) {
                for (int i = 0; i < avgSize; i++) {
                    stars.add(new Point((int) (Math.random() * gui.getWidth()), (int) (Math.random() * gui.getHeight())));
                }
            }

            for (Point p : stars) {
                if (Math.random() < 0.995) {
                    g.setColor(Color.white);
                } else {
                    g.setColor(Color.black);
                }
                g.fillOval(p.x, p.y, 2, 2);
            }
        }

        private void drawLegend(Graphics g) {
            g.setColor(Color.white);
            g.drawString("X", gui.getWidth() - 15, 15);
            g.drawLine(gui.getWidth() - 75, 10, gui.getWidth() - 20, 10);
            g.drawString("Y", gui.getWidth() - 15, 30);
            g.drawLine(gui.getWidth() - 11, 33, gui.getWidth() - 11, 83);
            g.drawString("Z", gui.getWidth() - 25, 27);
            g.drawLine(gui.getWidth() - 30, 30, gui.getWidth() - 65, 65);

        }

        private void drawSummary(Graphics g) {
            g.setColor(Color.white);
            g.drawString(info, 5, gui.getHeight() - 5);
        }

        private void drawCoords(Graphics g) {
            g.setColor(Color.white);
            g.drawString("(0, 0)", 5, 12);
            g.drawString("(" + gui.getWidth() + ", " + gui.getHeight() + ")", gui.getWidth() - 65, gui.getHeight() - 5);
        }

        private void drawGrid(Graphics g) {
            g.setColor(Color.darkGray);
            double xSpace = gui.getWidth() / 50.0;
            double ySpace = gui.getHeight() / 50.0;

            // Horiz
            for (int y = 0; y < ySpace; y++) {
                g.drawLine(0, y * 50, gui.getWidth(), y * 50);
            }

            // Vert
            for (int x = 0; x < xSpace; x++) {
                g.drawLine(x * 50, 0, x * 50, gui.getHeight());
            }
        }

        private void synchFramerate() {
            cycleTime = cycleTime + FRAME_DELAY;
            long difference = cycleTime - System.currentTimeMillis();
            try {
                Thread.sleep(Math.max(0, difference));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
